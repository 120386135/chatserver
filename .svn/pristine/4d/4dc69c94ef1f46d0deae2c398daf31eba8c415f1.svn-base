package com.chat.websocket;


import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.websocket.OnClose;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.server.ServerEndpoint;

import org.springframework.stereotype.Component;

import com.chat.model.Message;
import com.chat.pojo.ChatVO;
import com.google.gson.Gson;

/**
 * @ServerEndpoint 注解是一个类层次的注解，它的功能主要是将目前的类定义成一个websocket服务器端,
 * 注解的值将被用于监听用户连接的终端访问URL地址,客户端可以通过这个URL来连接到WebSocket服务器端
 */
@ServerEndpoint(value = "/websocket")
@Component
public class WebSocketTest {
	//是用来记录有多少websocket有多少session在运行  
    private static List<Session> sessions = new ArrayList<Session>();  
    //用来记录有多少个用户使用该websocket通道  
    private static List<String> usernames = new ArrayList<String>();  
    //用来记录用户名和该session进行绑定  
    private static Map<String,Session> map = new HashMap<String, Session>();  
    private String username;  
    private Gson gson = new Gson();  
      
    //打开链接  
    @OnOpen  
    public void open(Session session){  
        sessions.add(session);  
        String str = session.getQueryString();//可以得到ws：//路径？后面的所有字符串  
        username = str.split("=")[1];  
        try {  
            username = URLDecoder.decode(username, "utf-8");  
        } catch (UnsupportedEncodingException e) {  
            e.printStackTrace();  
        }  
        usernames.add(username);  
        map.put(username, session);  
        Message msg = new Message();  
        msg.setWelcome("欢迎"+username+":进入聊天室");  
        msg.setUsernames(usernames);  
        broadSend(sessions, msg.toJson());  
    }  
      
    //关闭连接  
    @OnClose  
    public void close(Session session){
        System.out.println(session.getId()+":已经关闭");  
        String str = session.getQueryString();  
        username = str.split("=")[1];  
        try {  
            username = URLDecoder.decode(username, "utf-8");  
        } catch (UnsupportedEncodingException e) {  
            e.printStackTrace();  
        }  
        usernames.remove(username);  
        sessions.remove(session);  
        Message msg = new Message();  
        msg.setExit(username+":离开聊天室");  
        msg.setUsernames(usernames);  
        broadSend(sessions, msg.toJson());  
    }  
      
    //客户端和服务器之间信息处理  
    @OnMessage  
    public void sendMessage(Session session,String msg){  
        ChatVO v = gson.fromJson(msg,ChatVO.class);  
        System.out.println(v.toString());  
        if (v.getType()==2) {  
            Message message = new Message();  
            message.setUsernames(usernames);  
            message.setContent(v.getMsg(),username);  
            broadSend(sessions,message.toJson());  
        }else {  
            //单聊  
        	Message message = new Message();  
            String toUsername = v.getToUser();  
            Session to_Session = map.get(toUsername);  
            Session from_Session = map.get(username);  
            message.setContent(v.getMsg(),v.getFromUser(),toUsername);  
            System.out.println(message.toJson());  
            try {  
                to_Session.getBasicRemote().sendText(message.toJson());  
                from_Session.getBasicRemote().sendText(message.toJson());  
            } catch (IOException e) {  
                e.printStackTrace();  
            }  
        }  
          
    }  
      
    //实现群聊  
    public void broadSend(List<Session> ss,String msg){  
        for (Session session : ss) {  
            try {  
                session.getBasicRemote().sendText(msg);  
            } catch (IOException e) {  
                e.printStackTrace();  
            }  
        }  
    }  }